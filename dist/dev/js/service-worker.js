"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _url = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/url"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/get-iterator"));

var _isArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/keys"));

var _set = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/set"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _serviceWorker = require("SAPPER_MODULE/service-worker");

var _LoggerBrowser = require("./main/browser/log/LoggerBrowser");

require("./initClientLog");

// @ts-ignore
var init = function init() {
  var catchLog = function catchLog(promise) {
    if (promise instanceof _promise.default) {
      return promise.catch(function (err) {
        _LoggerBrowser.logger.error(err);

        throw err;
      });
    }

    return promise;
  };

  var ASSETS = "cache" + _serviceWorker.timestamp; // `shell` is an array of all the files generated by the bundler,
  // `files` is an array of everything in the `static` directory

  var to_cache = (0, _concat.default)(_serviceWorker.shell).call(_serviceWorker.shell, _serviceWorker.files);
  var cached = new _set.default(to_cache);
  self.addEventListener('install', function (event) {
    event.waitUntil(catchLog(caches.open(ASSETS).then(function (cache) {
      return cache.addAll(to_cache);
    }).then(function () {
      self.skipWaiting();
    })));
  });
  self.addEventListener('activate', function (event) {
    event.waitUntil(catchLog((0, _keys.default)(caches).call(caches).then(
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(keys) {
        var _iterator, _isArray, _i, _ref2, key;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _iterator = keys, _isArray = (0, _isArray2.default)(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator2.default)(_iterator);

              case 1:
                if (!_isArray) {
                  _context.next = 7;
                  break;
                }

                if (!(_i >= _iterator.length)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("break", 17);

              case 4:
                _ref2 = _iterator[_i++];
                _context.next = 11;
                break;

              case 7:
                _i = _iterator.next();

                if (!_i.done) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("break", 17);

              case 10:
                _ref2 = _i.value;

              case 11:
                key = _ref2;

                if (!(key !== ASSETS)) {
                  _context.next = 15;
                  break;
                }

                _context.next = 15;
                return caches.delete(key);

              case 15:
                _context.next = 1;
                break;

              case 17:
                self.clients.claim();

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }())));
  });
  self.addEventListener('fetch', function (event) {
    if (event.request.method !== 'GET' || event.request.headers.has('range')) {
      return;
    }

    var url = new _url.default(event.request.url); // don't try to handle e.g. data: URIs
    // if (!url.protocol.startsWith('http')) {
    // 	return
    // }
    // ignore dev server requests

    if (url.hostname === self.location.hostname && url.port === self.location.port) {
      return;
    } // ignore external requests


    if (url.hostname !== self.location.hostname // except static files:
    && !/\.(png|jpe?g|gif|tiff?|woff2?|ttf|ico)$/ig.test(url.href)) {
      return;
    } // always serve static files and bundler-generated assets from cache


    if (url.host === self.location.host && cached.has(url.pathname)) {
      catchLog(event.respondWith(catchLog(caches.match(event.request))));
      return;
    } // for pages, you might want to serve a shell `service-worker-index.html` file,
    // which Sapper has generated for you. It's not right for every
    // app, but if it's right for yours then uncomment this section
    // if (url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
    // event.respondWith(caches.match('/service-worker-index.html'));
    // return;
    // }


    if (event.request.cache === 'only-if-cached') {
      return;
    } // for everything else, try the network first, falling back to
    // cache if the user is offline. (If the pages never change, you
    // might prefer a cache-first approach to a network-first one.)


    catchLog(event.respondWith(catchLog(caches.open("offline" + _serviceWorker.timestamp).then(
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(cache) {
        var response, _response;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return fetch(event.request);

              case 3:
                response = _context2.sent;
                _context2.next = 6;
                return cache.put(event.request, response.clone());

              case 6:
                return _context2.abrupt("return", response);

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](0);
                _context2.next = 13;
                return cache.match(event.request);

              case 13:
                _response = _context2.sent;

                if (!_response) {
                  _context2.next = 16;
                  break;
                }

                return _context2.abrupt("return", _response);

              case 16:
                throw _context2.t0;

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 9]]);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }()))));
  });
}; // init()